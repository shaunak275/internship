import requests
from bs4 import BeautifulSoup
import re
from urllib.parse import urljoin, urlparse
import logging
from flask import Flask, request, render_template, jsonify
import threading
import queue
import uuid
import numpy as np
from numba import cuda
import tkinter as tk
from tkinter import ttk, scrolledtext
from threading import Thread

# Configure logging
logging.basicConfig(filename='vuln_scan.log', level=logging.INFO, 
                   format='%(asctime)s - %(levelname)s - %(message)s')

app = Flask(__name__)

# Vulnerability payloads
XSS_PAYLOADS = [
    "<script>alert('xss')</script>",
    "<img src=x onerror=alert('xss')>",
    "javascript:alert('xss')"
]

SQLI_PAYLOADS = [
    "' OR '1'='1",
    "'; DROP TABLE users; --",
    "' UNION SELECT NULL, NULL, NULL --"
]

CSRF_PATTERNS = [
    r'<form[^>]*method=["\']?post["\']?[^>]*>',
    r'<input[^>]*name=["\']?_csrf["\']?[^>]*>',
]

# Store scan results
scan_results = []
scan_queue = queue.Queue()
scan_thread = None

def crawl_url(base_url, max_depth=2):
    """Crawl the website to find URLs and input fields."""
    visited = set()
    urls_to_scan = [(base_url, 0)]
    forms = []
    
    while urls_to_scan:
        url, depth = urls_to_scan.pop(0)
        if url in visited or depth > max_depth:
            continue
            
        try:
            response = requests.get(url, timeout=5)
            visited.add(url)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Find forms
            for form in soup.find_all('form'):
                action = form.get('action')
                if action:
                    form_url = urljoin(url, action)
                    inputs = form.find_all('input')
                    forms.append({
                        'url': form_url,
                        'method': form.get('method', 'get').lower(),
                        'inputs': [inp.get('name') for inp in inputs if inp.get('name')]
                    })
            
            # Find links
            for link in soup.find_all('a', href=True):
                href = urljoin(url, link['href'])
                if urlparse(href).netloc == urlparse(base_url).netloc and href not in visited:
                    urls_to_scan.append((href, depth + 1))
                    
        except Exception as e:
            logging.error(f"Error crawling {url}: {str(e)}")
    
    return forms, list(visited)

@cuda.jit
def check_patterns_cuda(response_data, patterns, output):
    """GPU-accelerated pattern matching for vulnerability detection."""
    idx = cuda.grid(1)
    if idx < len(response_data):
        for i in range(len(patterns)):
            if patterns[i] in response_data[idx]:
                output[idx] = 1

def test_xss(url, form_data):
    """Test for XSS vulnerabilities with GPU-accelerated pattern matching."""
    vulnerabilities = []
    
    for payload in XSS_PAYLOADS:
        for key in form_data:
            test_data = form_data.copy()
            test_data[key] = payload
            try:
                response = requests.post(url, data=test_data, timeout=5)
                response_text = response.text.encode('utf-8')
                
                # Prepare data for GPU
                response_array = np.array([response_text], dtype=np.bytes_)
                patterns_array = np.array([payload.encode('utf-8') for payload in XSS_PAYLOADS], dtype=np.bytes_)
                output_array = np.zeros(len(response_array), dtype=np.int32)
                
                # Copy to GPU
                d_response = cuda.to_device(response_array)
                d_patterns = cuda.to_device(patterns_array)
                d_output = cuda.to_device(output_array)
                
                # Launch GPU kernel
                threadsperblock = 256
                blockspergrid = (len(response_array) + (threadsperblock - 1)) // threadsperblock
                check_patterns_cuda[blockspergrid, threadsperblock](d_response, d_patterns, d_output)
                
                # Copy results back
                output = d_output.copy_to_host()
                
                if output[0] == 1:
                    vulnerabilities.append({
                        'type': 'XSS',
                        'url': url,
                        'payload': payload,
                        'severity': 'High',
                        'evidence': f"Payload {payload} reflected in response"
                    })
                    logging.warning(f"XSS detected at {url} with payload: {payload}")
            except Exception as e:
                logging.error(f"Error testing XSS at {url}: {str(e)}")
    
    return vulnerabilities

def test_sqli(url, form_data):
    """Test for SQL Injection vulnerabilities with GPU-accelerated error detection."""
    vulnerabilities = []
    error_patterns = ['sql syntax', 'mysql', 'sqlite', 'postgresql']
    
    for payload in SQLI_PAYLOADS:
        for key in form_data:
            test_data = form_data.copy()
            test_data[key] = payload
            try:
                response = requests.post(url, data=test_data, timeout=5)
                response_text = response.text.encode('utf-8')
                
                # Prepare data for GPU
                response_array = np.array([response_text], dtype=np.bytes_)
                patterns_array = np.array([p.encode('utf-8') for p in error_patterns], dtype=np.bytes_)
                output_array = np.zeros(len(response_array), dtype=np.int32)
                
                # Copy to GPU
                d_response = cuda.to_device(response_array)
                d_patterns = cuda.to_device(patterns_array)
                d_output = cuda.to_device(output_array)
                
                # Launch GPU kernel
                threadsperblock = 256
                blockspergrid = (len(response_array) + (threadsperblock - 1)) // threadsperblock
                check_patterns_cuda[blockspergrid, threadsperblock](d_response, d_patterns, d_output)
                
                # Copy results back
                output = d_output.copy_to_host()
                
                if output[0] == 1:
                    vulnerabilities.append({
                        'type': 'SQLi',
                        'url': url,
                        'payload': payload,
                        'severity': 'Critical',
                        'evidence': f"SQL error detected with payload: {payload}"
                    })
                    logging.warning(f"SQLi detected at {url} with payload: {payload}")
            except Exception as e:
                logging.error(f"Error testing SQLi at {url}: {str(e)}")
    
    return vulnerabilities

def test_csrf(form):
    """Test for CSRF vulnerabilities."""
    vulnerabilities = []
    
    try:
        response = requests.get(form['url'], timeout=5)
        soup = BeautifulSoup(response.text, 'html.parser')
        form_html = str(soup.find('form', action=form['url'].split('/')[-1]))
        
        if form['method'] == 'post' and not any(re.search(pattern, form_html, re.IGNORECASE) for pattern in CSRF_PATTERNS[1:]):
            vulnerabilities.append({
                'type': 'CSRF',
                'url': form['url'],
                'payload': None,
                'severity': 'Medium',
                'evidence': 'No CSRF token found in POST form'
            })
            logging.warning(f"CSRF vulnerability detected at {form['url']}")
    except Exception as e:
        logging.error(f"Error testing CSRF at {form['url']}: {str(e)}")
    
    return vulnerabilities

def run_scan(target_url, output_text=None):
    """Run the vulnerability scan."""
    global scan_results
    scan_results = []
    scan_id = str(uuid.uuid4())
    
    logging.info(f"Starting scan for {target_url} with ID: {scan_id}")
    
    # Crawl the website
    forms, urls = crawl_url(target_url)
    
    # Test each form for vulnerabilities
    for form in forms:
        form_data = {inp: 'test' for inp in form['inputs']}
        scan_results.extend(test_xss(form['url'], form_data))
        scan_results.extend(test_sqli(form['url'], form_data))
        scan_results.extend(test_csrf(form))
    
    # Update GUI if provided
    if output_text:
        output_text.delete(1.0, tk.END)
        for result in scan_results:
            output_text.insert(tk.END, f"Type: {result['type']}\nURL: {result['url']}\nSeverity: {result['severity']}\nEvidence: {result['evidence'] or 'N/A'}\n\n")
    
    logging.info(f"Scan completed for {target_url}. Found {len(scan_results)} vulnerabilities.")
    return scan_id

def scan_worker():
    """Background worker for processing scan queue."""
    while True:
        target_url, output_text = scan_queue.get()
        run_scan(target_url, output_text)
        scan_queue.task_done()

# Tkinter GUI
class VulnerabilityScannerGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("Web Vulnerability Scanner")
        self.root.geometry("600x400")
        
        # URL input
        tk.Label(root, text="Target URL:").pack(pady=5)
        self.url_entry = tk.Entry(root, width=50)
        self.url_entry.pack(pady=5)
        
        # Scan button
        self.scan_button = tk.Button(root, text="Start Scan", command=self.start_scan)
        self.scan_button.pack(pady=5)
        
        # Results display
        self.results_text = scrolledtext.ScrolledText(root, width=70, height=15)
        self.results_text.pack(pady=10)
        
    def start_scan(self):
        target_url = self.url_entry.get()
        if not target_url:
            self.results_text.delete(1.0, tk.END)
            self.results_text.insert(tk.END, "Please enter a valid URL.\n")
            return
        
        if not target_url.startswith(('http://', 'https://')):
            target_url = 'http://' + target_url
        
        self.results_text.delete(1.0, tk.END)
        self.results_text.insert(tk.END, "Scanning... Please wait.\n")
        self.scan_button.config(state='disabled')
        
        # Run scan in a separate thread
        Thread(target=self.run_scan_thread, args=(target_url,)).start()
    
    def run_scan_thread(self, target_url):
        scan_queue.put((target_url, self.results_text))
        self.root.after(1000, self.enable_button)
    
    def enable_button(self):
        self.scan_button.config(state='normal')

# Flask Routes
@app.route('/')
def index():
    return render_template('index.html')

@app.route('/start_scan', methods=['POST'])
def start_scan():
    target_url = request.form.get('url')
    if not target_url:
        return jsonify({'error': 'URL is required'}), 400
    
    if not target_url.startswith(('http://', 'https://')):
        target_url = 'http://' + target_url
    
    scan_queue.put((target_url, None))
    return jsonify({'message': 'Scan started', 'scan_id': str(uuid.uuid4())})

@app.route('/results')
def get_results():
    return jsonify({'results': scan_results})

# HTML Template for Flask
@app.route('/static/index.html')
def serve_index():
    return """
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Web Vulnerability Scanner</title>
        <script src="https://cdn.tailwindcss.com"></script>
        <script>
            async function startScan() {
                const url = document.getElementById('url').value;
                const response = await fetch('/start_scan', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/x-www-form-urlencoded'},
                    body: `url=${encodeURIComponent(url)}`
                });
                const data = await response.json();
                alert(data.message);
                setTimeout(fetchResults, 5000); // Poll results after 5 seconds
            }

            async function fetchResults() {
                const response = await fetch('/results');
                const data = await response.json();
                const resultsDiv = document.getElementById('results');
                resultsDiv.innerHTML = '';
                data.results.forEach(result => {
                    resultsDiv.innerHTML += `
                        <div class="p-4 bg-red-100 mb-2 rounded">
                            <strong>Type:</strong> ${result.type}<br>
                            <strong>URL:</strong> ${result.url}<br>
                            <strong>Severity:</strong> ${result.severity}<br>
                            <strong>Evidence:</strong> ${result.evidence || 'N/A'}
                        </div>`;
                });
            }
        </script>
    </head>
    <body class="p-8 bg-gray-100">
        <h1 class="text-2xl font-bold mb-4">Web Vulnerability Scanner</h1>
        <div class="mb-4">
            <input id="url" type="text" placeholder="Enter target URL" class="p-2 border rounded">
            <button onclick="startScan()" class="bg-blue-500 text-white p-2 rounded ml-2">Start Scan</button>
        </div>
        <div id="results" class="mt-4"></div>
    </body>
    </html>
    """

if __name__ == '__main__':
    # Start the scan worker thread
    scan_thread = threading.Thread(target=scan_worker, daemon=True)
    scan_thread.start()
    
    # Start Tkinter GUI in a separate thread
    root = tk.Tk()
    gui = VulnerabilityScannerGUI(root)
    
    # Start Flask in the main thread
    flask_thread = Thread(target=lambda: app.run(debug=True, use_reloader=False))
    flask_thread.start()
    
    # Run Tkinter GUI
    root.mainloop()
